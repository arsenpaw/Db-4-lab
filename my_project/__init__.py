"""
2022
apavelchak@gmail.com
© Andrii Pavelchak
"""

import os
import re
from datetime import datetime
from http import HTTPStatus
import secrets
from typing import Dict, Any
from urllib.parse import quote_plus

from dotenv import load_dotenv
from flasgger import Swagger
from flask import Flask, jsonify
from flask_restx import Api, Resource
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import text
from sqlalchemy_utils import database_exists, create_database
from apispec import APISpec
from apispec_webframeworks.flask import FlaskPlugin
from flask_swagger_ui import get_swaggerui_blueprint
from flask import jsonify
from my_project.auth.route import register_routes

SECRET_KEY = "SECRET_KEY"
SQLALCHEMY_DATABASE_URI = "SQLALCHEMY_DATABASE_URI"
MYSQL_ROOT_USER = "MYSQL_ROOT_USER"
MYSQL_ROOT_PASSWORD = "MYSQL_ROOT_PASSWORD"

# Database
db = SQLAlchemy()

todos = {}



def init_autodoc_swagger(app: Flask) -> None:
    app.config.setdefault("SWAGGER", {
        "uiversion": 3,
        "title": "Pets Shop API",
        "openapi": "3.0.3",
    })

    swagger_template = {
        "openapi": "3.0.3",
        "info": {
            "title": "Pets Shop API",
            "version": "1.0.0",
            "description": "Autogenerated Swagger docs",
            "contact": {"name": "Arsen Pavliuk", "email": "test@gmail.com"},
            "license": {"name": "MIT"},
        },
        "servers": [
            {"url": "/"}
        ],
        "components": {
            "securitySchemes": {
                "bearerAuth": {
                    "type": "http",
                    "scheme": "bearer",
                    "bearerFormat": "JWT"
                }
            }
        },
        "security": [{"bearerAuth": []}],
    }

    Swagger(app, template=swagger_template)

def create_app(app_config: Dict[str, Any], additional_config: Dict[str, Any]) -> Flask:
    """
    Creates Flask application
    :param app_config: Flask configuration
    :param additional_config: additional configuration
    :return: Flask application object
    """
    _process_input_config(app_config, additional_config)
    app = Flask(__name__)
    app.config["SECRET_KEY"] = secrets.token_hex(16)
    app.config = {**app.config, **app_config}
    _init_db(app)
    register_routes(app)

    # _init_swagger(app)
    _init_function(app)
    _init_procedures(app)
    _init_trigger(app)
    _init_employee_award(app,5,5)
    _init_positions(app)
    _do_cursor_task(app)

    init_autodoc_swagger(app)
    return app


def _do_cursor_task(app:Flask):
    with open("cursor.sql", "r") as file:
        sql_script = file.read()
    with app.app_context() as connection:
        db.session.execute(text(sql_script))
        print("SQL script executed successfully.")


def _init_positions(app: Flask):
    with app.app_context():
        db.session.execute(
            """
            DROP PROCEDURE IF EXISTS insert_positions;
            CREATE PROCEDURE insert_positions()
            BEGIN
                DECLARE i INT DEFAULT 20;
            
                WHILE i < 30 DO
                    INSERT IGNORE INTO position (id, title)
                    VALUES (i, CONCAT('Noname', i));
                    SET i = i + 1;
                END WHILE;
            END;
            """
        )

        db.session.execute("CALL insert_positions();")
        db.session.commit()


def _init_employee_award(app: Flask, current_group_id: int,current_employee_id: int) -> None:
    with app.app_context():
        db.session.execute("CALL AddEmployeeGroup(:current_group_id, :current_employee_id)", {
            'current_group_id': current_group_id,
            'current_employee_id': current_employee_id
        })
        db.session.commit()


def _init_procedures(app: Flask) -> None:
    with app.app_context():
        db.session.execute('''
            DROP PROCEDURE IF EXISTS AddEmployeeGroup;
                CREATE PROCEDURE AddEmployeeGroup(
                IN p_current_group_id INT,
                IN p_current_employee_id INT
            )
            BEGIN
                INSERT IGNORE  INTO employee_groups (current_group_id, current_employee_id)
                VALUES (p_current_group_id, p_current_employee_id);
            END;
          ''')
        db.session.commit()

def _init_function(app: Flask) -> None:
    with app.app_context():
        db.session.execute('''
        DROP FUNCTION IF EXISTS YoungestChild;
        CREATE FUNCTION YoungestChild() 
        RETURNS DATE
        DETERMINISTIC
        BEGIN
            DECLARE youngest_date DATE;
            SELECT MIN(admission_date) INTO youngest_date 
            FROM test.child_history;
            RETURN youngest_date;
        END;
        ''')
        db.session.execute('''
           DROP PROCEDURE IF EXISTS ExecSelect;
            CREATE PROCEDURE ExecSelect()
            BEGIN
                SELECT YoungestChild() AS AdmissionDate;
            END;
        ''')

        db.session.commit()
        result = db.session.execute('CALL ExecSelect() ').scalar()
        print(f"The youngest child has {result} admision date")


def _init_trigger(app: Flask) -> None:
    with app.app_context():
        #  as fk constraint
        db.session.execute('''
        DROP TRIGGER IF EXISTS trigger_gender_id;
        CREATE TRIGGER trigger_gender_id
        BEFORE INSERT ON employee
        FOR EACH ROW
        BEGIN
            IF NEW.Id < 0 THEN
                SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Primary key cannot be negative';
            END IF;
            IF NOT EXISTS (SELECT 1 FROM gender WHERE gender.Id = NEW.gender_id) THEN
                SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'No such gender exist';
            END IF;
        END;
        ''')
        #update
        db.session.execute('''
               DROP TRIGGER IF EXISTS trigger_gender_id_up;
               CREATE TRIGGER trigger_gender_id_up
               BEFORE UPDATE ON employee
               FOR EACH ROW
               BEGIN
                   IF NEW.Id < 0 THEN
                       SIGNAL SQLSTATE '45000'
                       SET MESSAGE_TEXT = 'Primary key cannot be negative';
                   END IF;
                   IF NOT EXISTS (SELECT 1 FROM gender WHERE gender.Id = NEW.gender_id) THEN
                       SIGNAL SQLSTATE '45000'
                       SET MESSAGE_TEXT = 'No such gender exist';
                   END IF;
               END;
               ''')
        #  double zero limiter
        db.session.execute('''
               DROP TRIGGER IF EXISTS double_zerro_trigger;
               CREATE TRIGGER double_zerro_trigger
               BEFORE INSERT ON gender 
               FOR EACH ROW
               BEGIN
                   IF RIGHT(NEW.Id,2) = '00' THEN
                       SIGNAL SQLSTATE '45000'
                       SET MESSAGE_TEXT = 'Identifier cannot have double zero due to the rule of universe';
                   END IF;
               END;
               ''')
        # update
        db.session.execute('''
               DROP TRIGGER IF EXISTS double_zerro_trigger_upd;
               CREATE TRIGGER double_zerro_trigger_upd
               BEFORE UPDATE ON gender 
               FOR EACH ROW
               BEGIN
                   IF RIGHT(NEW.Id,2) = '00' THEN
                       SIGNAL SQLSTATE '45000'
                       SET MESSAGE_TEXT = 'Identifier cannot have double zero due to the rule of universe';
                   END IF;
               END;
               ''')

        # max 6 chars and min 3  create
        db.session.execute('''
                        DROP TRIGGER IF EXISTS award_limiter;
                        CREATE TRIGGER award_limiter
                        BEFORE INSERT ON award
                        FOR EACH ROW
                        BEGIN
                            IF CHAR_LENGTH(NEW.description) <= 3 OR CHAR_LENGTH(NEW.description) > 6 THEN 
                                SIGNAL SQLSTATE '45000'
                                SET MESSAGE_TEXT = 'Tanos said that award description must be at least 6 characters.';
                            END IF;
                        END;

                       ''')
        # update
        db.session.execute('''
                        DROP TRIGGER IF EXISTS award_limiter_upd;
                        CREATE TRIGGER award_limiter_upd
                        BEFORE UPDATE ON award
                        FOR EACH ROW
                        BEGIN
                            IF CHAR_LENGTH(NEW.description) <= 3 OR CHAR_LENGTH(NEW.description) > 6 THEN 
                                SIGNAL SQLSTATE '45000'
                                SET MESSAGE_TEXT = 'Tanos said that award description must be at least 6 characters.';
                            END IF;
                        END;

                       ''')


        # forbid delete
        db.session.execute('''
                              DROP TRIGGER IF EXISTS on_kindergarten_remove;
                              CREATE TRIGGER on_kindergarten_remove
                              BEFORE DELETE ON kindergarten 
                              FOR EACH ROW
                              BEGIN                              
                                  SIGNAL SQLSTATE '45000'
                                  SET MESSAGE_TEXT = 'Removing kindergarden is not the jedi way';
                              END;
                              ''')

        db.session.commit()



def _init_swagger(app: Flask) -> None:
    api = Api(
        app,
        version="1.0",
        title="Pavelchak Test Backend",
        description="Autogenerated Swagger docs",
        doc="/swagger"
    )

    ns = api.namespace("number", description="Number operations")

    @ns.route("/<string:todo_id>")
    class TodoSimple(Resource):
        def get(self, todo_id):
            return todos, HTTPStatus.OK

        def put(self, todo_id):
            todos[todo_id] = todo_id
            return todos, HTTPStatus.CREATED

def _init_db(app: Flask) -> None:
    """
    Initializes DB with SQLAlchemy
    :param app: Flask application object
    """
    # add SSL engine options to existing config
    app.config.setdefault("SQLALCHEMY_ENGINE_OPTIONS", {})



    db.init_app(app)

    if not database_exists(app.config["SQLALCHEMY_DATABASE_URI"]):
        create_database(app.config["SQLALCHEMY_DATABASE_URI"])

    import my_project.auth.domain
    with app.app_context():
        db.create_all()

def _process_input_config(app_config: Dict[str, Any], additional_config: Dict[str, Any]) -> None:
    """
    Resolve DB connection string from environment first, then from a URI template.
    Expects app_config["SQLALCHEMY_DATABASE_URI"] to be either a full DSN or a template
    like:
      - "mysql+pymysql://{user}:{password}@host:3306/db?ssl_mode=REQUIRED"
      - "mysql+pymysql://{}:{}@host:3306/db?ssl_mode=REQUIRED"
    """
    load_dotenv()
    # 1) Full DSN via env wins
    conn = os.getenv(SQLALCHEMY_DATABASE_URI)
    if conn:
        app_config["SQLALCHEMY_DATABASE_URI"] = conn
        return

    # 2) Build from template using env → additional_config
    user = os.getenv(MYSQL_ROOT_USER, str(additional_config.get("MYSQL_ROOT_USER", "")))
    pwd  = os.getenv(MYSQL_ROOT_PASSWORD, str(additional_config.get("MYSQL_ROOT_PASSWORD", "")))

    template = app_config.get("SQLALCHEMY_DATABASE_URI", "")
    if not template:
        raise ValueError("SQLALCHEMY_DATABASE_URI is missing and no CONNECTION_STRING provided in env.")

    # Named placeholders
    if "{user}" in template or "{password}" in template:
        app_config["SQLALCHEMY_DATABASE_URI"] = template.format(
            user=user,
            password=quote_plus(pwd),  # encodes specials like ! @ # etc.
        )
        return

    # Positional placeholders
    if "{}" in template:
        app_config["SQLALCHEMY_DATABASE_URI"] = template.format(
            user, quote_plus(pwd)
        )
        return

    # No placeholders: leave as-is
    app_config["SQLALCHEMY_DATABASE_URI"] = template